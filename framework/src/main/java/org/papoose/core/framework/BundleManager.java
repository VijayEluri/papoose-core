/**
 *
 * Copyright 2007 (C) The original author or authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.papoose.core.framework;

import java.io.IOException;
import java.io.InputStream;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Logger;

import org.apache.xbean.classloader.ResourceLocation;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.BundleException;
import org.osgi.framework.BundleListener;
import org.osgi.framework.Constants;
import org.osgi.framework.FrameworkEvent;
import org.osgi.framework.FrameworkListener;
import org.osgi.framework.ServiceEvent;
import org.osgi.framework.ServiceListener;
import org.osgi.framework.ServicePermission;
import org.osgi.framework.ServiceReference;
import org.osgi.framework.Version;

import org.papoose.core.framework.spi.ArchiveStore;
import org.papoose.core.framework.spi.BundleStore;
import org.papoose.core.framework.spi.Solution;
import org.papoose.core.framework.spi.StartManager;
import org.papoose.core.framework.spi.Store;


/**
 * @version $Revision$ $Date$
 */
public class BundleManager
{
    private final static String CLASS_NAME = BundleManager.class.getName();
    private final Logger LOGGER = Logger.getLogger(CLASS_NAME);
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Map<String, AbstractBundle> locations = new HashMap<String, AbstractBundle>();
    private final Map<Long, AbstractBundle> installedbundles = new HashMap<Long, AbstractBundle>();
    private final Map<Long, BundleImpl> bundles = new HashMap<Long, BundleImpl>();
    private final Papoose framework;
    private final Store store;
    private StartManager startManager;
    private long bundleCounter = 1;


    public BundleManager(Papoose framework, Store store)
    {
        this.framework = framework;
        this.store = store;
        this.startManager = new DefaultStartManager(this);
    }

    public Store getStore()
    {
        return store;
    }

    public void setStartManager(StartManager startManager)
    {
        this.startManager = startManager;
    }

    public InputStream getInputStream(int bundleId)
    {
        return null;  //To change body of created methods use File | Settings | File Templates.
    }

    public InputStream getInputStream(int bundleId, int generation) throws IOException
    {
        return null;  //todo: consider this autogenerated code
    }

    public InputStream getInputStream(int bundleId, int generation, int location) throws IOException
    {
        return null;  //todo: consider this autogenerated code
    }

    public void recordBundleHasStarted(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public Bundle getBundle(long bundleId)
    {
        return installedbundles.get(bundleId);
    }

    public Bundle getBundle(String symbolicName)
    {
        return null;  //todo: consider this autogenerated code
    }

    public Bundle[] getBundles()
    {
        return new Bundle[0];  //todo: consider this autogenerated code
    }

    public Bundle installSystemBundle(Version version) throws BundleException
    {
        LOGGER.entering(CLASS_NAME, "installSystemBundle");

        if (locations.containsKey(Constants.SYSTEM_BUNDLE_LOCATION)) return locations.get(Constants.SYSTEM_BUNDLE_LOCATION);

        final long bundleId = 0;
        try
        {
            BundleStore bundleStore = store.allocateBundleStore(bundleId, Constants.SYSTEM_BUNDLE_LOCATION);

            AbstractBundle bundle = new SystemBundleImpl(framework, bundleId, bundleStore, version);

            locations.put(Constants.SYSTEM_BUNDLE_LOCATION, bundle);
            installedbundles.put(bundleId, bundle);
            bundles.put(bundleId, (BundleImpl) bundle);
            framework.getResolver().added((BundleImpl) bundle);

            LOGGER.exiting(CLASS_NAME, "installSystemBundle", bundle);

            return bundle;
        }
        catch (BundleException be)
        {
            store.removeBundleStore(bundleId);
            throw be;
        }
        catch (Exception e)
        {
            store.removeBundleStore(bundleId);
            throw new BundleException("Error occured while loading location " + Constants.SYSTEM_BUNDLE_LOCATION, e);
        }
    }

    public void uninstallSystemBundle()
    {

    }

    public Bundle installBundle(String location, InputStream inputStream) throws BundleException
    {
        LOGGER.entering(CLASS_NAME, "installBundle", new Object[]{ location, inputStream });

        if (locations.containsKey(location)) return locations.get(location);

        long bundleId = bundleCounter++;
        try
        {
            BundleStore bundleStore = store.allocateBundleStore(bundleId, location);

            ArchiveStore archiveStore = store.allocateArchiveStore(framework, bundleId, inputStream);

            AbstractBundle bundle = allocateBundle(bundleId, location, bundleStore, archiveStore);

            bundle.markInstalled();

            locations.put(location, bundle);
            installedbundles.put(bundleId, bundle);
            if (bundle instanceof BundleImpl)
            {
                bundles.put(bundleId, (BundleImpl) bundle);
                framework.getResolver().added((BundleImpl) bundle);
            }

            return bundle;
        }
        catch (BundleException be)
        {
            store.removeBundleStore(bundleId);
            throw be;
        }
        catch (Exception e)
        {
            store.removeBundleStore(bundleId);
            throw new BundleException("Error occured while loading location " + location, e);
        }
    }

    public boolean resolve(Bundle target)
    {
        if (target.getState() != Bundle.INSTALLED) return false;

        try
        {
            BundleImpl bundleImpl = (BundleImpl) target;
            Set<Solution> solutions = framework.getResolver().resolve(bundleImpl);

            String bootDelegateString = (String) framework.getProperty(Constants.FRAMEWORK_BOOTDELEGATION);
            String[] bootDelegates = (bootDelegateString == null ? new String[]{ } : bootDelegateString.split(","));

            for (int i = 0; i < bootDelegates.length; i++) bootDelegates[i] = bootDelegates[i].trim();

            for (Solution solution : solutions)
            {
                BundleImpl bundle = solution.getBundle();
                ArchiveStore currentStore = bundle.getCurrentStore();
                Set<Wire> wires = solution.getWires();
                List<Wire> requiredBundles = new ArrayList<Wire>();

                Set<String> exportedPackages = new HashSet<String>();

                for (ImportDescription desc : currentStore.getBundleImportList())
                {
                    exportedPackages.addAll(desc.getPackageNames());
                }

                for (ExportDescription desc : currentStore.getBundleExportList())
                {
                    exportedPackages.addAll(desc.getPackages());
                }

                for (Wire wire : requiredBundles)
                {
                    exportedPackages.add(wire.getPackageName());
                }

                List<ResourceLocation> resourceLocations = new ArrayList<ResourceLocation>();
                Set<ArchiveStore> archiveStores = new HashSet<ArchiveStore>();

                BundleClassLoader classLoader = new BundleClassLoader(bundle.getLocation(),
                                                                      framework.getClassLoader(),
                                                                      framework,
                                                                      bundle,
                                                                      wires,
                                                                      requiredBundles,
                                                                      bootDelegates,
                                                                      exportedPackages.toArray(new String[exportedPackages.size()]),
                                                                      currentStore.getDynamicImportSet(),
                                                                      resourceLocations,
                                                                      archiveStores);

                bundle.setClassLoader(classLoader);

                bundle.setResolvedState();
            }
        }
        catch (BundleException e)
        {
            e.printStackTrace();  //todo: consider this autogenerated code
            return false;
        }
        return true; // todo: not correct
    }

    public Wire resolve(DynamicDescription dynamicDescription)
    {
        return null; // todo:
    }

    public void loadAndStartBundles()
    {
        try
        {
            List<BundleStore> bundleStores = store.loadBundleStores();

            for (BundleStore bundleStore : bundleStores)
            {
                long bundleId = bundleStore.getBundleId();

                if (bundleId == 0) continue;

                String location = bundleStore.getLocation();
                ArchiveStore archiveStore = store.loadArchiveStore(framework, bundleId);

                AbstractBundle bundle = allocateBundle(bundleId, location, bundleStore, archiveStore);

                locations.put(location, bundle);
                installedbundles.put(bundleId, bundle);
                if (bundle instanceof BundleImpl)
                {
                    BundleImpl b = (BundleImpl) bundle;
                    bundles.put(bundleId, b);
                    framework.getResolver().added(b);

                    if (b.getHeaders().get(Constants.BUNDLE_ACTIVATOR) != null) startManager.start(b);
                }
            }
        }
        catch (BundleException e)
        {
            e.printStackTrace();  //todo: consider this autogenerated code
        }
    }

    public void requestStart(Bundle bundle)
    {
        startManager.start(bundle);
    }

    public void requestStop(Bundle bundle)
    {
        startManager.stop(bundle);
    }

    public void performStart(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public void performStop(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public void uninstall(Bundle bundle)
    {
        //todo: consider this autogenerated code
        framework.getResolver().removed((BundleImpl) bundle);
    }

    public void unregisterServices(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public void releaseServices(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public void fireBundleEvent(final BundleEvent event)
    {
        Collection<AbstractBundle> bundles = installedbundles.values();

        for (final Bundle bundle : bundles)
        {
            if (bundle instanceof BundleImpl)
            {
                for (final BundleListener listener : ((BundleImpl) bundle).syncBundleListeners)
                {
                    try
                    {
                        if (System.getSecurityManager() == null)
                        {
                            if (bundle.getState() == Bundle.ACTIVE) listener.bundleChanged(event);
                        }
                        else
                        {
                            AccessController.doPrivileged(new PrivilegedAction<Void>()
                            {
                                public Void run()
                                {
                                    if (bundle.getState() == Bundle.ACTIVE) listener.bundleChanged(event);
                                    return null;
                                }
                            });
                        }
                    }
                    catch (Throwable throwable)
                    {
                        fireFrameworkEvent(new FrameworkEvent(FrameworkEvent.ERROR, bundle, throwable));
                    }
                }
            }
        }

        if ((event.getType() & (BundleEvent.LAZY_ACTIVATION | BundleEvent.STARTING | BundleEvent.STOPPING)) == 0)
        {
            for (Bundle b : bundles)
            {
                if (b instanceof BundleImpl)
                {
                    final BundleImpl bundle = (BundleImpl) b;

                    for (final BundleListener listener : bundle.bundleListeners)
                    {
                        bundle.getSerialExecutor().execute(new Runnable()
                        {
                            public void run()
                            {
                                try
                                {
                                    if (System.getSecurityManager() == null)
                                    {
                                        if (bundle.getState() == Bundle.ACTIVE) listener.bundleChanged(event);
                                    }
                                    else
                                    {
                                        AccessController.doPrivileged(new PrivilegedAction<Void>()
                                        {
                                            public Void run()
                                            {
                                                if (bundle.getState() == Bundle.ACTIVE) listener.bundleChanged(event);
                                                return null;
                                            }
                                        });
                                    }
                                }
                                catch (Throwable throwable)
                                {
                                    fireFrameworkEvent(new FrameworkEvent(FrameworkEvent.ERROR, bundle, throwable));
                                }
                            }
                        });
                    }
                }
            }
        }
    }

    public void fireFrameworkEvent(final FrameworkEvent event)
    {
        for (Bundle b : installedbundles.values())
        {
            if (b instanceof BundleImpl)
            {
                final BundleImpl bundle = (BundleImpl) b;

                for (final FrameworkListener listener : bundle.frameworkListeners)
                {
                    bundle.getSerialExecutor().execute(new Runnable()
                    {
                        public void run()
                        {
                            try
                            {
                                if (System.getSecurityManager() == null)
                                {
                                    if (bundle.getState() == Bundle.ACTIVE) listener.frameworkEvent(event);
                                }
                                else
                                {
                                    AccessController.doPrivileged(new PrivilegedAction<Void>()
                                    {
                                        public Void run()
                                        {
                                            if (bundle.getState() == Bundle.ACTIVE) listener.frameworkEvent(event);
                                            return null;
                                        }
                                    });
                                }
                            }
                            catch (Throwable throwable)
                            {
                                if (event.getType() != FrameworkEvent.ERROR)
                                {
                                    fireFrameworkEvent(new FrameworkEvent(FrameworkEvent.ERROR, bundle, throwable));
                                }
                            }
                        }
                    });
                }
            }
        }
    }

    public void fireServiceEvent(final ServiceEvent event)
    {
        ServiceReference reference = event.getServiceReference();
        String[] classes = (String[]) reference.getProperty(Constants.OBJECTCLASS);

        for (Bundle b : installedbundles.values())
        {
            if (b instanceof BundleImpl)
            {
                BundleImpl bundle = (BundleImpl) b;

                for (String clazz : classes)
                {
                    if (!b.hasPermission(new ServicePermission(clazz, ServicePermission.GET))) continue;

                    fireServiceEvent(event, bundle.allServiceListeners, b);

                    if (!reference.isAssignableTo(b, clazz)) continue;

                    fireServiceEvent(event, bundle.serviceListeners, b);
                }
            }
        }
    }

    public void readLock() throws InterruptedException
    {
        readWriteLock.readLock().lockInterruptibly();
    }

    public void readUnlock()
    {
        readWriteLock.readLock().unlock();
    }

    public void writeLock() throws InterruptedException
    {
        readWriteLock.writeLock().lockInterruptibly();
    }

    public void writeUnlock()
    {
        readWriteLock.writeLock().unlock();
    }

    protected void fireServiceEvent(final ServiceEvent event, Set<ServiceListener> listeners, final Bundle bundle)
    {
        for (final ServiceListener listener : listeners)
        {
            try
            {
                if (System.getSecurityManager() == null)
                {
                    if (bundle.getState() == Bundle.ACTIVE) listener.serviceChanged(event);
                }
                else
                {
                    AccessController.doPrivileged(new PrivilegedAction<Void>()
                    {
                        public Void run()
                        {
                            if (bundle.getState() == Bundle.ACTIVE) listener.serviceChanged(event);
                            return null;
                        }
                    });
                }
            }
            catch (Throwable throwable)
            {
                fireFrameworkEvent(new FrameworkEvent(FrameworkEvent.ERROR, bundle, throwable));
            }
        }
    }

    private AbstractBundle allocateBundle(long bundleId, String location, BundleStore bundleStore, ArchiveStore archiveStore)
    {
        return new BundleImpl(framework, bundleId, location, bundleStore, archiveStore);
    }
}
