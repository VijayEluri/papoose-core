/**
 *
 * Copyright 2007 (C) The original author or authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.papoose.core.framework;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.Attributes;
import java.util.jar.JarInputStream;
import java.util.jar.Manifest;
import java.util.logging.Logger;

import org.osgi.framework.Bundle;
import org.osgi.framework.BundleException;
import org.osgi.framework.Constants;
import org.osgi.framework.Version;

import org.papoose.core.framework.spi.BundleManager;
import org.papoose.core.framework.spi.BundleStore;
import org.papoose.core.framework.spi.Store;


/**
 * @version $Revision$ $Date$
 */
public class BundleManagerImpl implements BundleManager
{
    private final Logger logger = Logger.getLogger(getClass().getName());

    private final Papoose framework;
    private final Store store;
    private final Map<String, BundleImpl> locations = new HashMap<String, BundleImpl>();
    private long bundleCounter = 0;


    public BundleManagerImpl(Papoose framework, Store store)
    {
        this.framework = framework;
        this.store = store;
    }

    public InputStream getInputStream(int bundleId, int generation) throws IOException
    {
        return null;  //todo: consider this autogenerated code
    }

    public void recordBundleHasStarted(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public void resolve(Bundle bundle)
    {
        //todo: consider this autogenerated code
    }

    public Bundle getBundle(long bundleId)
    {
        return null;  //todo: consider this autogenerated code
    }

    public Bundle[] getBundles()
    {
        return new Bundle[0];  //todo: consider this autogenerated code
    }

    public Bundle installBundle(String location, InputStream inputStream) throws BundleException
    {
        logger.entering(getClass().getName(), "installBundle", new Object[]{location, inputStream});

        if (locations.containsKey(location)) return locations.get(location);

        long bundleId = bundleCounter++;
        try
        {
            BundleStore bundleStore = store.allocateBundleStore(bundleCounter++);

            File archive = bundleStore.getArchive();

            OutputStream outputStream = new FileOutputStream(archive);

            byte[] buffer = new byte[1024];
            int numRead;
            while ((numRead = inputStream.read(buffer)) != -1) outputStream.write(buffer, 0, numRead);

            outputStream.close();

            String bundleActivatorClass;
            List<String> bundleCategories;
            List<String> bundleClasspath;
            String bundleContactAddress;
            String bundleCopyright;
            String bundleDescription;
            String bundleDocUrl;
            String bundleLocalization;
            short bundleManifestVersion;
            String bundleName;
            List<NativeCodeDescription> bundleNativeCodeList;
            List<String> bundleExecutionEnvironment;
            String bundleSymbolicName;
            URL bundleUpdateLocation;
            String bundleVendor;
            Version bundleVersion;
            List<DynamicDescription> bundleDynamicImportList;
            List<ExportDescription> bundleExportList;
            List<String> bundleExportService;
            FragmentDescription bundleFragmentHost;
            List<ImportDescription> bundleImportList;
            List<String> bundleImportService;
            List<RequireDescription> bundleRequireBundle;

            JarInputStream jarInputStream = new JarInputStream(new FileInputStream(archive));
            Manifest manifest = jarInputStream.getManifest();

            Attributes attributes = manifest.getMainAttributes();

            bundleActivatorClass = attributes.getValue("Bundle-Activator");

            bundleCategories = obtainBundleCategories(attributes);

            bundleClasspath = obtainBundleClasspath(attributes);

            bundleContactAddress = attributes.getValue("Bundle-ContactAddress");

            bundleCopyright = attributes.getValue("Bundle-Copyright");

            bundleDescription = attributes.getValue("Bundle-Description");

            bundleDocUrl = attributes.getValue("Bundle-DocUrl");

            bundleLocalization = attributes.getValue("Bundle-Localization");

            bundleManifestVersion = Short.parseShort(attributes.getValue("Bundle-ManifestVersion"));

            bundleName = attributes.getValue("Bundle-Name");

            bundleNativeCodeList = obtainBundleNativeCodeList(attributes);

            bundleExecutionEnvironment = obtainBundleExecutionEnvironment(attributes);

            bundleSymbolicName = attributes.getValue("Bundle-SymbolicName");

            bundleUpdateLocation = obtainBundleUpdateLocation(attributes);

            bundleVendor = attributes.getValue("Bundle-Vendor");

            bundleVersion = Version.parseVersion(attributes.getValue("Bundle-Version"));

            bundleDynamicImportList = obtainBundleDynamicImportList(attributes);

            bundleExportList = obtainBundleExportList(attributes);

            bundleFragmentHost = obtainBundleFragementHost(attributes);

            bundleExportService = obtainBundleExportService(attributes);

            bundleImportList = obtainBundleImportList(attributes);

            bundleImportService = obtainBundleImportService(attributes);

            bundleRequireBundle = obtainBundleRequireBundle(attributes);

            BundleImpl bundle = new BundleImpl(null, framework, bundleStore, bundleId,
                                               bundleActivatorClass,
                                               bundleCategories,
                                               bundleClasspath,
                                               bundleContactAddress,
                                               bundleCopyright,
                                               bundleDescription,
                                               bundleDocUrl,
                                               bundleLocalization,
                                               bundleManifestVersion,
                                               bundleName,
                                               bundleNativeCodeList,
                                               bundleExecutionEnvironment,
                                               bundleSymbolicName,
                                               bundleUpdateLocation,
                                               bundleVendor,
                                               bundleVersion,
                                               bundleDynamicImportList,
                                               bundleExportList,
                                               bundleExportService,
                                               bundleFragmentHost,
                                               bundleImportList,
                                               bundleImportService,
                                               bundleRequireBundle);

            locations.put(location, bundle);

            return bundle;
        }
        catch (BundleException be)
        {
            store.removeBundleStore(bundleId);
            throw be;
        }
        catch (Exception e)
        {
            store.removeBundleStore(bundleId);
            throw new BundleException("Error occured while loading location " + location, e);
        }
        finally
        {
            try
            {
                inputStream.close();
            }
            catch (IOException ioe)
            {
                logger.warning("Error closing stream for " + location + ". " + ioe);
            }
        }
    }

    protected List<String> obtainBundleExecutionEnvironment(Attributes attributes)
    {
        List<String> result;

        if (attributes.containsKey("Bundle-ExecutionEnvironment"))
        {
            String[] tokens = attributes.getValue("Bundle-ExecutionEnvironment").split(",");
            result = new ArrayList<String>(tokens.length);

            for (String token : tokens) result.add(token.trim());
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    protected List<NativeCodeDescription> obtainBundleNativeCodeList(Attributes attributes) throws Exception
    {
        List<NativeCodeDescription> result;
        if (attributes.containsKey("Bundle-NativeCodeList"))
        {
            String[] nativecodes = attributes.getValue("Bundle-NativeCodeList").split(",");
            result = new ArrayList<NativeCodeDescription>(nativecodes.length);

            for (String nativecode : nativecodes)
            {
                String[] pathparams = nativecode.split(";");
                List<String> paths = new ArrayList<String>(1);
                Map<String, String> parameters = new HashMap<String, String>();
                NativeCodeDescription description = new NativeCodeDescription(paths, parameters);

                for (String pathparam : pathparams)
                {
                    if (pathparam.contains("="))
                    {
                        String[] keyval = pathparam.split("=");

                        if (keyval.length != 2) throw new BundleException("Malformed Bundle-NativeCodeList");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if ("osversion".equals(key))
                        {
                            if (!Util.callSetter(description, key, VersionRange.parseVersionRange(value))) throw new BundleException("Unable to set osversion");
                        }
                        else if ("filter".equals(key))
                        {
                            if (!Util.callSetter(description, key, new FilterImpl(framework.getParser().parse(value)))) throw new BundleException("Unable to set filter");
                        }
                        else
                        {
                            if (!Util.callSetter(description, key, keyval[1])) parameters.put(key, value);
                        }
                    }
                    else
                    {
                        paths.add(pathparam.trim());
                    }
                }

                result.add(description);
            }
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    protected URL obtainBundleUpdateLocation(Attributes attributes) throws Exception
    {
        if (attributes.containsKey("Bundle-UpdateLocation")) return new URL(attributes.getValue("Bundle-UpdateLocation"));
        else return null;
    }

    protected List<DynamicDescription> obtainBundleDynamicImportList(Attributes attributes) throws Exception
    {
        List<DynamicDescription> result;

        if (attributes.containsKey("DynamicImport-Package"))
        {
            String[] importDescriptions = attributes.getValue("DynamicImport-Package").split(",");
            result = new ArrayList<DynamicDescription>(importDescriptions.length);

            for (String importDescription : importDescriptions)
            {
                String[] packageparams = importDescription.split(";");
                List<String> paths = new ArrayList<String>(1);
                Map<String, String> parameters = new HashMap<String, String>();
                DynamicDescription description = new DynamicDescription(paths, parameters);

                for (String pathparam : packageparams)
                {
                    if (pathparam.contains("="))
                    {
                        String[] keyval = pathparam.split("=");

                        if (keyval.length != 2) throw new BundleException("Malformed DynamicImport-Package");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if ("version".equals(key))
                        {
                            if (!Util.callSetter(description, key, VersionRange.parseVersionRange(value))) throw new BundleException("Unable to set version");
                        }
                        else if ("bundle-symbolic-name".equals(key))
                        {
                            if (!Util.callSetter(description, key, value)) throw new BundleException("Unable to set bundle-symbolic-name");
                        }
                        else if ("bundle-version".equals(key))
                        {
                            if (!Util.callSetter(description, key, VersionRange.parseVersionRange(value))) throw new BundleException("Unable to set bundle-version");
                        }
                        else
                        {
                            if (!Util.callSetter(description, key, value)) parameters.put(key, value);
                        }
                    }
                    else
                    {
                        String path = pathparam.trim();

                        if (!Util.isValidWildcardName(path)) throw new BundleException("Invalid wildcard name");

                        paths.add(path);
                    }
                }

                result.add(description);
            }
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    protected List<String> obtainBundleClasspath(Attributes attributes)
    {
        List<String> result;

        if (attributes.containsKey("Bundle-Classpath"))
        {
            String[] tokens = attributes.getValue("Bundle-Classpath").split(",");
            result = new ArrayList<String>(tokens.length);

            for (String token : tokens) result.add(token.trim());
        }
        else
        {
            result = new ArrayList<String>(1);
            result.add(".");
        }

        return result;
    }

    protected List<String> obtainBundleCategories(Attributes attributes)
    {
        List<String> result;

        if (attributes.containsKey("Bundle-Category"))
        {
            String[] tokens = attributes.getValue("Bundle-Category").split(",");
            result = new ArrayList<String>(tokens.length);

            for (String token : tokens) result.add(token.trim());
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    protected List<ExportDescription> obtainBundleExportList(Attributes attributes) throws Exception
    {
        List<ExportDescription> result;

        if (attributes.containsKey("Export-Package"))
        {
            String[] exportDescriptions = Util.split(attributes.getValue("Export-Package"), ",");
            result = new ArrayList<ExportDescription>(exportDescriptions.length);

            for (String importDescription : exportDescriptions)
            {
                Set<String> keys = new HashSet<String>();
                String[] packageparams = importDescription.split(";");
                List<String> paths = new ArrayList<String>(1);
                Map<String, Object> parameters = new HashMap<String, Object>();
                ExportDescription description = new ExportDescription(paths, parameters);

                for (String pathparam : packageparams)
                {
                    if (pathparam.contains(":="))
                    {
                        String[] keyval = pathparam.split(":=");

                        if (keyval.length != 2) throw new BundleException("Malformed Export-Package");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if (keys.contains(key)) throw new BundleException("Attempted to reset attribute " + key);
                        else keys.add(key);

                        if ("uses".equals(key))
                        {
                            String[] tokens = value.split(",");
                            List<String> uses = new ArrayList();
                            if (!Util.callSetter(description, key, VersionRange.parseVersionRange(value))) throw new BundleException("Unable to set version");
                        }
                    }
                    else if (pathparam.contains("="))
                    {
                        String[] keyval = pathparam.split("=");

                        if (keyval.length != 2) throw new BundleException("Malformed Export-Package");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if (keys.contains(key)) throw new BundleException("Attempted to reset attribute " + key);
                        else keys.add(key);

                        if ("version".equals(key))
                        {
                            VersionRange versionRange = VersionRange.parseVersionRange(value);

                            if (!parameters.containsKey(key) && parameters.get(key).equals(versionRange)) throw new BundleException("Aliased versions do not match");

                            parameters.put(key, versionRange);
                        }
                        else if ("specification-version".equals(key))
                        {
                            VersionRange versionRange = VersionRange.parseVersionRange(value);

                            if (!parameters.containsKey("version") && parameters.get("version").equals(versionRange)) throw new BundleException("Aliased versions do not match");

                            parameters.put("version", versionRange);
                        }
                        else if ("bundle-symbolic-name".equals(key))
                        {
                            throw new BundleException("Attempted to set bundle-symbolic-name");
                        }
                        else if ("bundle-version".equals(key))
                        {
                            throw new BundleException("Attempted to set bundle-version");
                        }
                        else
                        {
                            parameters.put(key, value);
                        }
                    }
                    else
                    {
                        paths.add(pathparam.trim());
                    }
                }

                if (!parameters.containsKey("version")) parameters.put("version", ExportDescription.DEFAULT_VERSION);

                result.add(description);
            }
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    private FragmentDescription obtainBundleFragementHost(Attributes attributes) throws Exception
    {
        FragmentDescription result = null;

        if (attributes.containsKey("Fragment-Host"))
        {
            Map<String, Object> parameters = new HashMap<String, Object>();

            String tokens[] = attributes.getValue("Fragment-Host").split(";");

            for (int i = 1; i < tokens.length; i++)
            {
                String token = tokens[i];

                if (token.contains(":="))
                {
                    String[] keyval = token.split(":=");

                    if (keyval.length != 2) throw new BundleException("Malformed Fragment-Host");

                    String key = keyval[0].trim();
                    String value = keyval[1].trim();

                    if ("extension".equals(key))
                    {
                        try
                        {
                            if (!Util.callSetter(result, key, Extension.valueOf(value.toUpperCase()))) throw new BundleException("extension");
                        }
                        catch (IllegalArgumentException iae)
                        {
                            throw new BundleException("Unable to set extension", iae);
                        }
                    }
                }
                else if (token.contains("="))
                {
                    String[] keyval = token.split("=");

                    if (keyval.length != 2) throw new BundleException("Malformed Fragment-Host");

                    String key = keyval[0].trim();
                    String value = keyval[1].trim();

                    if ("bundle-version".equals(key))
                    {
                        try
                        {
                            if (!Util.callSetter(result, key, VersionRange.parseVersionRange(value))) throw new BundleException("Unable to set bundle-version");
                        }
                        catch (IllegalArgumentException iae)
                        {
                            throw new BundleException("Unable to set bundle-version", iae);
                        }
                    }
                    else
                    {
                        parameters.put(key, value);
                    }
                }

            }

            if (!parameters.containsKey("bundle-version")) parameters.put("bundle-version", ImportDescription.DEFAULT_VERSION_RANGE);

            result = new FragmentDescription(tokens[0], parameters);
        }

        return result;
    }

    protected List<String> obtainBundleExportService(Attributes attributes)
    {
        List<String> result;

        if (attributes.containsKey("Export-Service"))
        {
            String[] tokens = attributes.getValue("Export-Service").split(",");
            result = new ArrayList<String>(tokens.length);

            for (String token : tokens) result.add(token.trim());
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    private List<ImportDescription> obtainBundleImportList(Attributes attributes) throws Exception
    {
        List<ImportDescription> result;

        if (attributes.containsKey("Import-Package"))
        {
            String[] exportDescriptions = attributes.getValue("Import-Package").split(",");
            result = new ArrayList<ImportDescription>(exportDescriptions.length);

            for (String importDescription : exportDescriptions)
            {
                Set<String> keys = new HashSet<String>();
                String[] packageparams = importDescription.split(";");
                List<String> paths = new ArrayList<String>(1);
                Map<String, Object> parameters = new HashMap<String, Object>();
                ImportDescription description = new ImportDescription(paths, parameters);

                for (String pathparam : packageparams)
                {
                    if (pathparam.contains(":="))
                    {
                        String[] keyval = pathparam.split(":=");

                        if (keyval.length != 2) throw new BundleException("Malformed Import-Package");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if (keys.contains(key)) throw new BundleException("Attempted to reset parameter " + key);
                        else keys.add(key);

                        if ("resolution".equals(key))
                        {
                            try
                            {
                                if (!Util.callSetter(description, key, Resolution.valueOf(value.toUpperCase()))) throw new BundleException("Unable to set resolution");
                            }
                            catch (IllegalArgumentException iae)
                            {
                                throw new BundleException("Unable to set resolution", iae);
                            }
                        }
                    }
                    else if (pathparam.contains("="))
                    {
                        String[] keyval = pathparam.split("=");

                        if (keyval.length != 2) throw new BundleException("Malformed Import-Package");

                        String key = keyval[0].trim();
                        String value = keyval[1].trim();

                        if (keys.contains(key)) throw new BundleException("Attempted to reset parameter " + key);
                        else keys.add(key);

                        if ("version".equals(key))
                        {
                            VersionRange versionRange = VersionRange.parseVersionRange(value);

                            if (!parameters.containsKey(key) && parameters.get(key).equals(versionRange)) throw new BundleException("Aliased versions do not match");

                            parameters.put(key, versionRange);
                        }
                        else if ("specification-version".equals(key))
                        {
                            VersionRange versionRange = VersionRange.parseVersionRange(value);

                            if (!parameters.containsKey("version") && parameters.get("version").equals(versionRange)) throw new BundleException("Aliased versions do not match");

                            parameters.put("version", versionRange);
                        }
                        else if ("bundle-version".equals(key))
                        {
                            parameters.put(key, Version.parseVersion(value));
                        }
                        else
                        {
                            parameters.put(key, value);
                        }
                    }
                    else
                    {
                        paths.add(pathparam.trim());
                    }
                }

                if (!parameters.containsKey("version")) parameters.put("version", ImportDescription.DEFAULT_VERSION_RANGE);
                if (!parameters.containsKey("bundle-version")) parameters.put("bundle-version", ImportDescription.DEFAULT_VERSION_RANGE);

                result.add(description);
            }
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    private List<String> obtainBundleImportService(Attributes attributes)
    {
        List<String> result;

        if (attributes.containsKey("Import-Service"))
        {
            String[] tokens = attributes.getValue("Import-Service").split(",");
            result = new ArrayList<String>(tokens.length);

            for (String token : tokens) result.add(token.trim());
        }
        else
        {
            result = Collections.emptyList();
        }

        return result;
    }

    private List<RequireDescription> obtainBundleRequireBundle(Attributes attributes) throws BundleException
    {
        List<RequireDescription> result = null;

        if (attributes.containsKey(Constants.REQUIRE_BUNDLE))
        {
            result = new ArrayList<RequireDescription>();

            String[] descriptions = Util.split(attributes.getValue(Constants.REQUIRE_BUNDLE), ",");
            for (String description : descriptions)
            {
                Map<String, Object> parameters = new HashMap<String, Object>();
                RequireDescription requireDescription;
                int index = description.indexOf(';');

                if (index != -1)
                {
                    requireDescription = new RequireDescription(Util.checkSymbolName(description.substring(0, index)), parameters);

                    Util.parseParameters(description.substring(index + 1), requireDescription, parameters);
                }
                else
                {
                    requireDescription = new RequireDescription(Util.checkSymbolName(description), parameters);
                }

                if (requireDescription.getVisibility() == null) Util.callSetter(requireDescription, "visibility", Visibility.PRIVATE);
                if (requireDescription.getResolution() == null) Util.callSetter(requireDescription, "resolution", Resolution.MANDATORY);
                if (!parameters.containsKey("bundle-version")) parameters.put("bundle-version", RequireDescription.DEFAULT_VERSION_RANGE);

                result.add(requireDescription);
            }
        }

        return result;
    }
}
